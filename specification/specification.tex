\documentclass[a4paper,11pt]{article}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{lmodern}
\usepackage[utf8]{inputenc}
\usepackage[swedish,english]{babel}
\usepackage{setspace}
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{colortbl}


\begin{document}

\setlength\parindent{0em}
\setlength\parskip{1em}

\selectlanguage{english}

\title{Degree project specification}
\author{Adam Renberg\\\texttt{adamre@kth.se}}

\maketitle

\begin{tabular}{rll}
	\textbf{School:}  & School of Computer Science and Communication (CSC) at KTH \\
    \textbf{Company:} & Valtech, \texttt{http://www.valtech.se/} \\
\end{tabular}

\begin{tabular}{rll}
	\textbf{Supervisor, Valtech:} & Erland Ranvinge & \texttt{erland.ranvinge@valtech.se} \\
    \textbf{Supervisor, CSC:}     & Narges Khakpour & \texttt{nargeskh@kth.se} \\
    \textbf{Examiner:}		  & Johan HÃ¥stad	& \texttt{johanh@kth.se} \\
    \textbf{Coordinator, KTH:}	  & Ann Bengtsson & \texttt{ann@csc.kth.se} \\
\end{tabular}


\begin{spacing}{1.0}
\setlength\parskip{0.15em}
\tableofcontents
\end{spacing}

\section{Short Background}

Runtime verification (RV) is a dynamic approach to checking program correctness, in contrast to the more 
traditional static analysis tools of \emph{model checking}, \emph{bounded reachability} and \emph{theorem proving}. These are often very useful, but suffers from severe problems such as the
state explosion problem, incompleteness, undecidability and the overall difficulty of using them
on large programs. Moreover, static analysis only verifies the abstract model of the program, and cannot guarantee the correctness of the implementation or the dynamic properties of the executing code.

Runtime verification is a light-weight formal verification technique, see e.g. \cite{leucker08,delgado04}.
It verifies that specified properties hold during the execution of a program. It operates on a \emph{trace} of the \emph{current execution}, either while it is running (online), or at some other time and/or place (offline), and verifies the execution against a \emph{specification}.

The specification that should be verified is written in a formal
language, often a logic/calculus, such as linear temporal logic \cite{pnueli77}. To generate
a \emph{system model} for the logic (or an automaton thereof) to operate on, the target program
needs to emit and expose certain events and data. Many RV frameworks use \textit{code instrumentation}
to generate \textit{monitors} for this end.

When a violation against the specification occurs, simple actions can be taken (e.g. log the error, send emails, etc.), or more complex responses initiated, resulting in a \textit{self-healing} or \textit{self-adapting} system (see e.g. \cite{huebscher08}).

On the other end of the program-correctness-checking spectrum is \emph{testing}, which is the
practical approach of checking that the program, given a certain input, produces the correct output.
Testing is not complete, and lacks a formal foundation, so it cannot be used for formal verification. 
Testing can be a complement to formal techniques, such as RV (but is in many places the sole correctness-checking tool).

\textit{Unit testing} is the concept of writing small tests, or test suites, for the units in
a program, be it functions, classes, etc. These tests are used during development to test the 
functionality of the units. They aim to reduce the risk of breaking existing functionality when 
developing new features or modifying existing code (by preventing regression).

Writing unit tests, often using unit testing \textit{frameworks} such as JUnit \cite{junit}
for Java and unittest \cite{python-unittest} for Python, is a common practice on many
development teams.


\section{Problem}

\subsection{Problem Definition}

How can runtime verification specifications be written in a manner that resembles the syntax of
the target program's programming language, and the structure of unit tests?

Suggested title: \textit{Test-inspired runtime verification - using a unit test-like specification syntax for runtime verification}.


\subsection{Motivation}

Checking that a program works correctly is of great interest to software developers, and
formal verification techniques can often help. As mentioned above, traditional approaches
can be impractical with larger programs, and verification by testing is informal.
Runtime verification can here be a lightweight addition to the list.

The specification languages used by RV approaches are often based
on formal logic and not written in the target program's programming language. 
This means that writing the specifications require specific knowledge and expertise in mathematics. 
It also requires mental-context switching and special tools
to support this specialised language syntax. In contrast, unit testing frameworks often
utilize the programming language to great effect, and their use is wide spread.

If RV specifications more resembled unit tests, and were written in the target program's
programming language, it might popularize the use of runtime verification.


\section{Literature}

\subsection{Previous Research}

Runtime verification is a somewhat new area of research, but the research on verification and formal methods goes back several centuries.

Unit testing is also quite young, perhaps having started in the 90s, and it isn't as much researched as formal methods. Testing in general is very old.

The work on the linear temporal logic (and other logics), on runtime verification in general and its applications, on code instrumentation (e.g. \cite{aspectj,matusiak09}), and on unit testing and their frameworks will lay the foundation of this work.

I've already studied several papers, mostly in runtime verification, verification tools, logics, etc.
A list of these can be found at the project's website: \texttt{http://tgwizard.github.com/thesis}.

\subsection{Examination}

The literature study will be examined as a part of the report, as the report will contain
both a general description of RV and unit testing, and more detailed sections on research related to the problem.


\section{Method}

The work will consist of two parts:


\subsection{Approach}

I will do a background and state-of-the-art inventory of RV and unit testing. The focus will lie on the syntax used for writing the specifications/tests, and how they are executed and the target program instrumented.

I will also answer the following questions:

\begin{enumerate}
	\item How should the syntax for the specification be defined,
		so that it looks similar to that for unit tests, but works for RV?
		Which language could be used? Which unit testing framework to take inspiration from?
	\item How can this be related to a formal logic, to ensure the correctness of the specification?
		What formal logic should be used? 
	\item How should the code be instrumented to monitor the system and build the system model?
		How should the specification be transformed so it can be executed? 
	\item How will this be used to (online) verify the system against the specification?
\end{enumerate}

I will focus on item 1 and 3.


\subsection{Evaluation}

In this part I will implement an RV framework prototype, based on the previous
investigation.

If possible, I will also attempt to use the resulting framework to enable runtime verification on a project at Valtech.


\section{Resources}

If I attempt to try the prototype framework on a project at Valtech, I need to get access to such a project. One suggested possible project is the Valtech Intranet.


\section{Working Procedure}

I will work on the degree project 50\% and 50\% on projects at Valtech, in periods of
two weeks degree project, two weeks work. This fits well into the iteration-planning at
Valtech. During the summer I will almost exclusively work on the degree project, and also
use some of my vacation hours to work on it.

Other required work related to the degree project, such as doing the opposition of
another student's work, will take time from the work above and require
flexibility in planning.

I will keep a diary, \texttt{http://tgwizard.github.com/thesis}, in which I will write on my progress. 

\subsection{Approximate Time Plan}


\begin{center}
	\renewcommand{\arraystretch}{1.5}
	\arrayrulecolor{Gray}
	\begin{tabular}{ l l l | p{8cm} }
		\textbf{Start} & \textbf{Weeks} &  & \textbf{Work} \\
		\noalign{\smallskip}\hline\noalign{\smallskip}
		
		May & \textit{1w in May/June} & \textbf{1w} &
		Writing, and doing the research for, this specification.
		\\
		
		May & \textit{2w in May}, v23, v26, v27 & \textbf{5w} &
		Doing background \& research.
		\\
		
		9/7 & v28 & \textbf{1w} &
		Writing the background part of the report.
		\\
		
		16/7 & v29, v30, v31, v32, v33 & \textbf{5w} &
		Investigating and evaluating "what to do".
		\\
		
		13/8 & v34& \textbf{1w} &
		Writing about the investigation.
		\\
		
		20/8 & v35, v36, v37, v38 & \textbf{4w} &
		Implementing and evaluating the RV framework.
		Possibly testing and analysing the RV framework on a project.
		\\
		
		24/9 & v39, v40, v41 & \textbf{3w} &
		Writing and finishing the report.
		\\
		
	\end{tabular}
\end{center}

vXX means week-of-the-year XX, calculated the Swedish way. I.e., week 28 starts on the 9th of July.

I will take the weeks v24 and v25 off, as well as about 1 week in august (not planned).
\textbf{The weeks I will be working at Valtech haven't been written into the time table.}

Total: 20 weeks. End date: \textbf{12 October 2012} (very optimistic).

\section{Licensing}

I will license any resulting code under some open source license, and any documentation, including the report, under Creative Commons Attribution 3.0 Unported License \cite{cc-by} (or something similar).


\begin{thebibliography}{9}

\bibitem{leucker08}
	Martin Leucker, Christian Schallhart.
	A brief account of runtime verification.
	In \emph{The Journal of Logic and Algebraic Programming 78}.
	2009, pages 293-303.

\bibitem{delgado04}
	Nelly Delgado, Ann Q. Gates, Steve Roach.
	A Taxonomy and Catalog of Runtime Software-Fault Monitoring Tools.
	In \emph{IEEE Transactions on Software Engineering}.
	IEEE, 2004.

\bibitem{pnueli77}
	Amir Pnueli.
	The temporal logic of programs. 
	In \emph{Proceedings of the 18th IEEE Symposium on the Foundations of Computer Science (FOCS-77)}.
	IEEE, 1977

\bibitem{huebscher08}
	Markus C. Huebscher, Julie A. McCann.
	A survey of Autonomic Computing \- degrees, models and applications.
	In \emph{ACM Computing Surveys}, Volume 40 Issue 3.
	ACM, 2008.
	
\bibitem{junit}
	Kent Beck, Eric Gamma, David Saff.
	JUnit.
	\texttt{http://junit.sourceforge.net/},
	June 2012.

\bibitem{python-unittest}
	Python Software Foundation.
	unittest.
	\texttt{http://docs.python.org/library/unittest.html},
	June 2012.

\bibitem{aspectj}
	AspectJ.
	\texttt{http://www.eclipse.org/aspectj/},
	June 2012

\bibitem{matusiak09}
	Martin Matusiak.
	Strategies for aspect oriented programming in Python.
	2009

\bibitem{cc-by}
	Creative Commons.
	Creative Commons Attribution 3.0 Unported License.
	\texttt{http://creativecommons.org/licenses/by/3.0/}

\end{thebibliography}

\end{document}
